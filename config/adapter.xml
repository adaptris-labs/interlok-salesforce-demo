<?xml version="1.0" encoding="UTF-8"?>
<adapter>
  <unique-id>${adapter.unique.id}</unique-id>
  <shared-components>
    <connections>
      <jms-connection>
        <connection-error-handler class="jms-connection-error-handler"/>
        <unique-id>LocalActiveMQ</unique-id>
        <vendor-implementation class="basic-active-mq-implementation">
          <broker-url>tcp://localhost:61616</broker-url>
        </vendor-implementation>
      </jms-connection>
      <jdbc-pooled-connection>
        <unique-id>LocalMySQL</unique-id>
        <test-statement>SELECT DATABASE(), VERSION(), NOW(), USER();</test-statement>
        <driver-imp>com.mysql.jdbc.Driver</driver-imp>
        <username>${local_db_username}</username>
        <password>${local_db_password}</password>
        <connect-url>${local_db_connect_url}</connect-url>
      </jdbc-pooled-connection>
      <jetty-embedded-connection>
        <unique-id>jetty-connection</unique-id>
      </jetty-embedded-connection>
    </connections>
  </shared-components>
  <channel-list>
    <channel>
      <unique-id>ContactManager</unique-id>
      <message-error-handler class="standard-processing-exception-handler">
        <processing-exception-service class="service-list">
          <services>
            <embedded-scripting-service>
              <language>javascript</language>
              <continue-on-fail>true</continue-on-fail>
              <script>
                <![CDATA[
                    var objectHeaders = message.getObjectHeaders();

                    var exceptionReport = new java.util.HashMap();
                    exceptionReport.put("workflow", message.getMetadataValue("workflowId"));
                    var exception = objectHeaders["java.lang.Exception"];
                    if(exception != null) {
                      var flatException = new java.lang.Exception(exception.getMessage());
                      flatException.setStackTrace(exception.getStackTrace());
                      exceptionReport.put("exception", flatException);
                      exceptionReport.put("exceptionMessage", exception.getMessage());
                    }
                    var exceptionLocation = objectHeaders["java.lang.Exception_Cause"];
                    if(exceptionLocation != null) {
                      exceptionReport.put("exceptionLocation", exceptionLocation);
                    }
                    message.setContent(new com.fasterxml.jackson.databind.ObjectMapper().writer(new com.fasterxml.jackson.core.util.DefaultPrettyPrinter()).writeValueAsString(exceptionReport), "UTF-8");

                  ]]>
              </script>
            </embedded-scripting-service>
            <standalone-producer>
              <producer class="jetty-standard-response-producer">
                <status-provider class="http-configured-status">
                  <status>INTERNAL_ERROR_500</status>
                </status-provider>
                <send-payload>true</send-payload>
              </producer>
            </standalone-producer>
          </services>
        </processing-exception-service>
      </message-error-handler>
      <consume-connection class="shared-connection">
        <lookup-name>jetty-connection</lookup-name>
      </consume-connection>
      <produce-connection class="null-connection"/>
      <workflow-list>
        <standard-workflow>
          <consumer class="jetty-message-consumer">
            <unique-id>/contacts</unique-id>
            <destination class="configured-consume-destination">
              <destination>/contacts/*</destination>
            </destination>
            <warn-after-message-hang-millis>20000</warn-after-message-hang-millis>
            <parameter-handler class="jetty-http-parameters-as-metadata"/>
            <header-handler class="jetty-http-ignore-headers"/>
          </consumer>
          <service-collection class="service-list">
            <services>
              <log-message-service>
                <include-payload>true</include-payload>
                <log-level>DEBUG</log-level>
              </log-message-service>
              <branching-service-collection>
                <unique-id>HTTP Router</unique-id>
                <first-service-id>route</first-service-id>
                <services>
                  <embedded-scripting-service>
                    <unique-id>route</unique-id>
                    <language>javascript</language>
                    <branching-enabled>true</branching-enabled>
                    <script><![CDATA[
                    var routes = [
                      { method:  "GET",
                        pattern: "^/contacts/swagger$",
                        vars:    [],
                        service: "swagger" },
                      { method:  "GET",
                        pattern: "^/contacts/(.*)$",
                        vars:    ["LocalContactId"],
                        service: "retrieve" },
                      { method:  "DELETE",
                        pattern: "^/contacts/(.*)$",
                        vars:    ["LocalContactId"],
                        service: "delete" },
                      { method:  "GET",
                        pattern: "^/contacts$",
                        vars:    [],
                        service: "list" },
                      { method:  "POST",
                        pattern: "^/contacts$",
                        vars:    [],
                        service: "save" },
                      { method:  "PATCH",
                        pattern: "^/contacts/(.*)$",
                        vars:    ["LocalContactId"],
                        service: "update" }
                    ]

                    var method = message.getMetadataValue("httpmethod")
                    var uri    = message.getMetadataValue("jettyURI")
                    message.setNextServiceId("NotHandled")
                    // Match each route against the actual Jetty metadata from the HTTP request
                    for(var i=0; i<routes.length; i++) {
                      log.trace("Trying to match route: " + JSON.stringify(routes[i]));

                      if(method != routes[i].method) {
                        log.trace("HTTP method " + routes[i].method + " did not match " + method);
                        continue;
                      }

                      var result = new RegExp(routes[i].pattern).exec(uri)
                      if(result == null) {
                        log.trace("Pattern " + routes[i].pattern + " did not match " + uri);
                        continue;
                      }

                      // Both method and pattern match, now parse out the vars
                      for(var j=0; j<routes[i].vars.length; j++) {
                        var name  = routes[i].vars[j]
                        var value = result[j+1]
                        log.trace("Adding metadata " + name + "=" + value)
                        message.addMetadata(name, value)
                      }

                      message.setNextServiceId(routes[i].service)

                      break
                    }
                  ]]></script>
                  </embedded-scripting-service>
                  <service-list>
                    <unique-id>save</unique-id>
                    <services>
                      <!--
                      {
                        "FirstName" : "Lewin",
                        "LastName" : "Chan",
                        "Email" : "lchan@adaptris-abclabs.com",
                        "Phone" : "0700 987654",
                        "Account" : "ABC Labs",
                        "AccountId" : "0010Y00000H1Fg6QAF"
                      }
                      -->
                      <json-path-service>
                        <source class="string-payload-data-input-parameter"/>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.FirstName</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>FirstName</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.LastName</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>LastName</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.Email</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>Email</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.Phone</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>Phone</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.Account</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>Account</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.AccountId</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>AccountId</metadata-key>
                          </target>
                        </json-path-execution>
                      </json-path-service>
                      <!-- Generate a UID -->
                      <generate-unique-metadata-value-service>
                        <unique-id>Generate ContactID</unique-id>
                        <metadata-key>LocalContactId</metadata-key>
                      </generate-unique-metadata-value-service>
                      <jdbc-raw-data-capture-service>
                        <unique-id>Insert Contact</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalMySQL</lookup-name>
                        </connection>
                        <statement-timeout>
                          <unit>SECONDS</unit>
                          <interval>30</interval>
                        </statement-timeout>
                        <statement>INSERT INTO `contacts` (id, FirstName, LastName, Phone, Email, Account, AccountID, LastUpdated, Created) VALUES (?,?,?,?,?,?,?,NOW(),NOW());</statement>
                        <parameter-applicator class="sequential-parameter-applicator"/>
                        <jdbc-statement-parameter>
                          <query-string>LocalContactId</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>FirstName</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>LastName</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>Phone</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>Email</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>Account</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>AccountId</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                      </jdbc-raw-data-capture-service>
                      <payload-from-metadata-service>
                        <unique-id>Return ID</unique-id>
                        <metadata-tokens>
                          <key-value-pair>
                            <key>LocalContactId</key>
                            <value>__CONTACT_ID__</value>
                          </key-value-pair>
                        </metadata-tokens>
                        <template><![CDATA[{"id" : "__CONTACT_ID__"}]]></template>
                      </payload-from-metadata-service>
                    </services>
                  </service-list>

                  <service-list>
                    <unique-id>update</unique-id>
                    <services>
                    <!--
                      {
                        "FirstName" : "Lewin",
                        "LastName" : "Chan",
                        "Email" : "lchan@adaptris-abclabs.com",
                        "Phone" : "0700 987654",
                        "Account" : "ABC Labs",
                        "AccountId" : "0010Y00000H1Fg6QAF"
                      }
                    -->
                      <json-path-service>
                        <source class="string-payload-data-input-parameter"/>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.FirstName</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>FirstName</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.LastName</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>LastName</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.Email</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>Email</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.Phone</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>Phone</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.Account</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>Account</metadata-key>
                          </target>
                        </json-path-execution>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.AccountId</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>AccountId</metadata-key>
                          </target>
                        </json-path-execution>
                      </json-path-service>

                      <jdbc-raw-data-capture-service>
                        <unique-id>Update Contact</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalMySQL</lookup-name>
                        </connection>
                        <statement-timeout>
                          <unit>SECONDS</unit>
                          <interval>30</interval>
                        </statement-timeout>
                        <statement>UPDATE contacts SET FirstName=?, LastName=?, Phone=?, Email=?, Account=?, AccountId=?, LastUpdated=NOW() where id=?</statement>
                        <parameter-applicator class="sequential-parameter-applicator"/>
                        <jdbc-statement-parameter>
                          <query-string>FirstName</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>LastName</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>Phone</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>Email</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>Account</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>AccountId</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>LocalContactId</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                      </jdbc-raw-data-capture-service>
                      <jdbc-data-query-service>
                        <unique-id>Select ALL Records</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalMySQL</lookup-name>
                        </connection>
                        <statement-creator class="jdbc-configured-sql-statement">
                          <statement>select * from contacts where id=?</statement>
                        </statement-creator>
                        <jdbc-statement-parameter>
                          <query-string>LocalContactId</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <result-set-translator class="jdbc-json-payload-translator"/>
                      </jdbc-data-query-service>
                    </services>
                  </service-list>


                  <service-list>
                    <unique-id>delete</unique-id>
                    <services>
                      <jdbc-raw-data-capture-service>
                        <unique-id>Delete Contact</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalMySQL</lookup-name>
                        </connection>
                        <statement-timeout>
                          <unit>SECONDS</unit>
                          <interval>30</interval>
                        </statement-timeout>
                        <statement>DELETE FROM contacts where id=?</statement>
                        <jdbc-statement-parameter>
                          <query-string>LocalContactId</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                      </jdbc-raw-data-capture-service>
                      <payload-from-metadata-service>
                        <unique-id>Return ID</unique-id>
                        <metadata-tokens>
                          <key-value-pair>
                            <key>LocalContactId</key>
                            <value>__CONTACT_ID__</value>
                          </key-value-pair>
                        </metadata-tokens>
                        <template><![CDATA[{"id" : "__CONTACT_ID__", "status": "deleted"}]]></template>
                      </payload-from-metadata-service>
                    </services>
                  </service-list>

                  <service-list>
                    <unique-id>list</unique-id>
                    <services>
                      <jdbc-data-query-service>
                        <unique-id>Select ALL Records</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalMySQL</lookup-name>
                        </connection>
                        <statement-creator class="jdbc-configured-sql-statement">
                          <statement>select * from contacts</statement>
                        </statement-creator>
                        <result-set-translator class="jdbc-json-payload-translator"/>
                      </jdbc-data-query-service>
                    </services>
                  </service-list>

                  <service-list>
                    <unique-id>retrieve</unique-id>
                    <services>
                      <jdbc-data-query-service>
                        <unique-id>Select By ContactID</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalMySQL</lookup-name>
                        </connection>
                        <statement-creator class="jdbc-configured-sql-statement">
                          <statement>select * from contacts where id=?</statement>
                        </statement-creator>
                        <jdbc-statement-parameter>
                          <query-string>LocalContactId</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <result-set-translator class="jdbc-json-payload-translator"/>
                      </jdbc-data-query-service>
                    </services>
                  </service-list>

                  <service-list>
                    <unique-id>swagger</unique-id>
                    <services>
                      <aggregating-fs-consume-service>
                        <fs-consumer>
                          <destination class="consume-destination-from-metadata">
                            <default-destination>${swagger.yaml.file}</default-destination>
                          </destination>
                          <delete-aggregated-files>false</delete-aggregated-files>
                          <message-aggregator class="replace-with-first-message-aggregator"/>
                        </fs-consumer>
                      </aggregating-fs-consume-service>
                      <yaml-to-json>
                        <source class="string-payload-data-input-parameter"/>
                        <target class="string-payload-data-output-parameter"/>
                      </yaml-to-json>
                      <!-- rewrite the swagger so it has the correct hostname -->
                      <json-transform-service>
                        <source-json class="string-payload-data-input-parameter"/>
                        <target-json class="string-payload-data-output-parameter"/>
                        <mapping-spec class="constant-data-input-parameter">
                          <value>[{ "operation": "remove", "spec": {"host": "" }},{"operation": "shift", "spec": { "*": "&amp;","#${adapter.api.hostname}": "host"}}]</value>
                        </mapping-spec>
                        <metadata-filter class="regex-metadata-filter"/>
                      </json-transform-service>
                    </services>
                  </service-list>

                  <service-list>
                    <unique-id>NotHandled</unique-id>
                    <services>
                      <add-metadata-service>
                        <metadata-element>
                          <key>ResponseCode</key>
                          <value>400</value>
                        </metadata-element>
                      </add-metadata-service>
                      <payload-from-metadata-service>
                        <metadata-tokens/>
                        <template><![CDATA[{"Status" : "Not Handled; please check"}]]></template>
                      </payload-from-metadata-service>
                    </services>
                  </service-list>

                </services>
              </branching-service-collection>
              <standalone-producer>
                <unique-id>Send Response</unique-id>
                <producer class="jetty-standard-response-producer">
                  <status-provider class="http-metadata-status">
                    <code-key>ResponseCode</code-key>
                    <default-status>OK_200</default-status>
                  </status-provider>
                  <response-header-provider class="jetty-no-response-headers"/>
                  <content-type-provider class="http-configured-content-type-provider">
                    <mime-type>application/json</mime-type>
                  </content-type-provider>
                  <send-payload>true</send-payload>
                </producer>
              </standalone-producer>
            </services>
          </service-collection>
        </standard-workflow>
      </workflow-list>
    </channel>
    <channel>
      <auto-start>false</auto-start>
      <unique-id>Database Monitor</unique-id>
      <workflow-list>
        <standard-workflow>
          <unique-id>New Contacts</unique-id>
          <consumer class="polling-trigger">
            <destination class="configured-consume-destination">
              <configured-thread-name>NewContactsQuery</configured-thread-name>
            </destination>
            <poller class="random-interval-poller"/>
            <template>&lt;root/&gt;</template>
          </consumer>
          <service-collection class="service-list">
            <services>
              <jdbc-data-query-service>
                <unique-id>Select New Records</unique-id>
                <connection class="shared-connection">
                  <lookup-name>LocalMySQL</lookup-name>
                </connection>
                <statement-creator class="jdbc-configured-sql-statement">
                  <statement>select * from contacts where ContactId is null</statement>
                </statement-creator>
                <result-set-translator class="jdbc-xml-payload-translator">
                  <display-column-errors>true</display-column-errors>
                  <column-name-style>Capitalize</column-name-style>
                </result-set-translator>
                <parameter-applicator class="sequential-parameter-applicator"/>
              </jdbc-data-query-service>
              <basic-message-splitter-service>
                <unique-id>Process Contacts Individually</unique-id>
                <connection class="shared-connection">
                  <lookup-name>LocalActiveMQ</lookup-name>
                </connection>
                <producer class="jms-topic-producer">
                  <destination class="configured-produce-destination">
                    <destination>sfdc.create.contact</destination>
                  </destination>
                  <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
                  <message-translator class="text-message-translator"/>
                  <session-factory class="jms-default-producer-session"/>
                </producer>
                <splitter class="xpath-message-splitter">
                  <xpath>//Row</xpath>
                  <encoding>UTF-8</encoding>
                </splitter>
              </basic-message-splitter-service>
            </services>
          </service-collection>
        </standard-workflow>
        <standard-workflow>
          <unique-id>Updated Contacts</unique-id>
          <consumer class="polling-trigger">
            <destination class="configured-consume-destination">
              <configured-thread-name>QueryUpdatedContacts</configured-thread-name>
            </destination>
            <poller class="random-interval-poller"/>
            <template>&lt;root/&gt;</template>
          </consumer>
          <service-collection class="service-list">
            <services>
              <retrieve-from-cache>
                <unique-id>GetLastExecutionFromCache</unique-id>
                <cache class="default-ehcache">
                  <cache-name>ADAPTER_DEFAULT_CACHE</cache-name>
                  <max-elements-in-memory>0</max-elements-in-memory>
                </cache>
                <cache-entry-evaluator>
                  <error-on-empty-key>false</error-on-empty-key>
                  <error-on-empty-value>false</error-on-empty-value>
                  <key-translator class="static-cache-value-translator">
                    <value>LastExecution</value>
                  </key-translator>
                  <value-translator class="metadata-cache-value-translator">
                    <metadata-key>LastExecution</metadata-key>
                  </value-translator>
                </cache-entry-evaluator>
                <exception-if-not-found>false</exception-if-not-found>
              </retrieve-from-cache>
              <branching-service-collection>
                <unique-id>CheckLastUpdated</unique-id>
                <first-service-id>CheckCache</first-service-id>
                <services>
                  <metadata-exists-branching-service>
                    <unique-id>CheckCache</unique-id>
                    <metadata-key>LastExecution</metadata-key>
                    <default-service-id>GenerateInitial</default-service-id>
                    <metadata-exists-service-id>Execute</metadata-exists-service-id>
                  </metadata-exists-branching-service>
                  <service-list>
                    <unique-id>Execute</unique-id>
                    <services/>
                  </service-list>
                  <service-list>
                    <unique-id>GenerateInitial</unique-id>
                    <services>
                      <add-timestamp-metadata-service>
                        <metadata-key>LastExecution</metadata-key>
                        <date-format>yyyy-MM-dd' 'HH:mm:ss</date-format>
                      </add-timestamp-metadata-service>
                    </services>
                  </service-list>
                </services>
              </branching-service-collection>
              <add-formatted-metadata-service>
                <unique-id>Generate SELECT Statement</unique-id>
                <format-string>SELECT * FROM contacts WHERE LastUpdated &gt; '%s' AND ContactId is not null AND LastUpdated > Created</format-string>
                <argument-metadata-key>LastExecution</argument-metadata-key>
                <metadata-key>JDBC_UPDATED_CONTACTS</metadata-key>
              </add-formatted-metadata-service>
              <jdbc-data-query-service>
                <unique-id>Select Updated Records</unique-id>
                <connection class="shared-connection">
                  <lookup-name>LocalMySQL</lookup-name>
                </connection>
                <statement-timeout>
                  <unit>SECONDS</unit>
                  <interval>15</interval>
                </statement-timeout>
                <statement-creator class="jdbc-metadata-sql-statement">
                  <metadata-key>JDBC_UPDATED_CONTACTS</metadata-key>
                </statement-creator>
                <result-set-translator class="jdbc-xml-payload-translator">
                  <display-column-errors>true</display-column-errors>
                  <column-name-style>Capitalize</column-name-style>
                </result-set-translator>
              </jdbc-data-query-service>
              <basic-message-splitter-service>
                <unique-id>Process Contacts Individually</unique-id>
                <connection class="shared-connection">
                  <lookup-name>LocalActiveMQ</lookup-name>
                </connection>
                <producer class="jms-topic-producer">
                  <destination class="configured-produce-destination">
                    <destination>sfdc.update.contact</destination>
                  </destination>
                  <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
                  <message-translator class="text-message-translator"/>
                  <session-factory class="jms-default-producer-session"/>
                </producer>
                <splitter class="xpath-message-splitter">
                  <copy-metadata>true</copy-metadata>
                  <copy-object-metadata>false</copy-object-metadata>
                  <xpath>//Row</xpath>
                  <encoding>UTF-8</encoding>
                </splitter>
              </basic-message-splitter-service>
              <add-timestamp-metadata-service>
                <metadata-key>LastExecution</metadata-key>
                <date-format>yyyy-MM-dd' 'HH:mm:ss</date-format>
                <always-replace>true</always-replace>
              </add-timestamp-metadata-service>
              <add-to-cache>
                <unique-id>AddLastExecution</unique-id>
                <cache class="default-ehcache">
                  <cache-name>ADAPTER_DEFAULT_CACHE</cache-name>
                  <max-elements-in-memory>0</max-elements-in-memory>
                </cache>
                <cache-entry-evaluator>
                  <key-translator class="static-cache-value-translator">
                    <value>LastExecution</value>
                  </key-translator>
                  <value-translator class="metadata-cache-value-translator">
                    <metadata-key>LastExecution</metadata-key>
                  </value-translator>
                </cache-entry-evaluator>
              </add-to-cache>
            </services>
          </service-collection>
        </standard-workflow>
      </workflow-list>
    </channel>
    <channel>
      <auto-start>true</auto-start>
      <consume-connection class="shared-connection">
        <lookup-name>LocalActiveMQ</lookup-name>
      </consume-connection>
      <produce-connection class="shared-connection">
        <lookup-name>LocalActiveMQ</lookup-name>
      </produce-connection>
      <unique-id>Housekeeping</unique-id>
      <workflow-list>
        <standard-workflow>
          <unique-id>RemoveAuthorizationHeaderFromCache</unique-id>
          <consumer class="jms-topic-consumer">
            <destination class="configured-consume-destination">
              <configured-thread-name>sfdc.authenticate.delete</configured-thread-name>
              <destination>sfdc.authenticate.delete</destination>
            </destination>
            <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
            <message-translator class="auto-convert-message-translator"/>
            <durable>false</durable>
          </consumer>
          <service-collection class="service-list">
            <services>
              <remove-from-cache>
                <unique-id>RemoveRevokedAuthorizationHeaderFromCache</unique-id>
                <continue-on-fail>true</continue-on-fail>
                <cache class="default-ehcache">
                  <cache-name>ADAPTER_DEFAULT_CACHE</cache-name>
                  <max-elements-in-memory>0</max-elements-in-memory>
                </cache>
                <cache-entry-evaluator>
                  <error-on-empty-key>false</error-on-empty-key>
                  <error-on-empty-value>false</error-on-empty-value>
                  <key-translator class="static-cache-value-translator">
                    <value>CachedOAuthHeader</value>
                  </key-translator>
                  <value-translator class="metadata-cache-value-translator">
                    <metadata-key>Authorization</metadata-key>
                  </value-translator>
                </cache-entry-evaluator>
                <exception-if-not-found>false</exception-if-not-found>
              </remove-from-cache>
            </services>
          </service-collection>
          <producer class="jms-topic-producer">
            <destination class="jms-reply-to-destination"/>
            <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
            <message-translator class="text-message-translator"/>
            <session-factory class="jms-default-producer-session"/>
          </producer>
        </standard-workflow>
        <standard-workflow>
          <unique-id>Salesforce Authentication</unique-id>
          <consumer class="jms-topic-consumer">
            <destination class="configured-consume-destination">
              <configured-thread-name>sfdc.authenticate</configured-thread-name>
              <destination>sfdc.authenticate</destination>
            </destination>
            <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
            <message-translator class="auto-convert-message-translator"/>
            <durable>false</durable>
          </consumer>
          <service-collection class="service-list">
            <services>
              <retrieve-from-cache>
                <unique-id>RetrieveAuthorizationHeaderFromCache</unique-id>
                <cache class="default-ehcache">
                  <cache-name>ADAPTER_DEFAULT_CACHE</cache-name>
                  <max-elements-in-memory>0</max-elements-in-memory>
                </cache>
                <cache-entry-evaluator>
                  <error-on-empty-key>false</error-on-empty-key>
                  <error-on-empty-value>false</error-on-empty-value>
                  <key-translator class="static-cache-value-translator">
                    <value>CachedOAuthHeader</value>
                  </key-translator>
                  <value-translator class="metadata-cache-value-translator">
                    <metadata-key>Authorization</metadata-key>
                  </value-translator>
                </cache-entry-evaluator>
                <exception-if-not-found>false</exception-if-not-found>
              </retrieve-from-cache>
              <branching-service-collection>
                <unique-id>CheckCache</unique-id>
                <first-service-id>CheckAuthorizationHeaderInCache</first-service-id>
                <services>
                  <metadata-exists-branching-service>
                    <unique-id>CheckAuthorizationHeaderInCache</unique-id>
                    <metadata-key>Authorization</metadata-key>
                    <default-service-id>SignIn</default-service-id>
                    <metadata-exists-service-id>AbortSignIn</metadata-exists-service-id>
                  </metadata-exists-branching-service>
                  <service-list>
                    <unique-id>AbortSignIn</unique-id>
                    <services/>
                  </service-list>
                  <service-list>
                    <unique-id>SignIn</unique-id>
                    <services>
                      <get-oauth-token>
                        <token-key>Authorization</token-key>
                        <access-token-builder class="salesforce-access-token">
                          <username>${sfdc_username}</username>
                          <password>${sfdc_password}</password>
                          <consumer-key>${sfdc_consumerKey}</consumer-key>
                          <consumer-secret>${sfdc_consumerSecret}</consumer-secret>
                        </access-token-builder>
                      </get-oauth-token>
                      <add-to-cache>
                        <unique-id>AddAuthorizationHeaderToCache</unique-id>
                        <cache class="default-ehcache">
                          <cache-name>ADAPTER_DEFAULT_CACHE</cache-name>
                          <max-elements-in-memory>0</max-elements-in-memory>
                        </cache>
                        <cache-entry-evaluator>
                          <error-on-empty-key>false</error-on-empty-key>
                          <error-on-empty-value>false</error-on-empty-value>
                          <key-translator class="static-cache-value-translator">
                            <value>CachedOAuthHeader</value>
                          </key-translator>
                          <value-translator class="metadata-cache-value-translator">
                            <metadata-key>Authorization</metadata-key>
                          </value-translator>
                        </cache-entry-evaluator>
                      </add-to-cache>
                    </services>
                  </service-list>
                </services>
              </branching-service-collection>
            </services>
          </service-collection>
          <producer class="jms-topic-producer">
            <unique-id>Return Response</unique-id>
            <destination class="jms-reply-to-destination"/>
            <message-translator class="text-message-translator"/>
          </producer>
        </standard-workflow>
      </workflow-list>
    </channel>
    <channel>
      <auto-start>true</auto-start>
      <consume-connection class="shared-connection">
        <lookup-name>LocalActiveMQ</lookup-name>
      </consume-connection>
      <produce-connection class="null-connection"/>
      <unique-id>Salesforce Contacts</unique-id>
      <workflow-list>
        <standard-workflow>
          <unique-id>Create Contact</unique-id>
          <consumer class="jms-topic-consumer">
            <unique-id>sfdc.create.contact</unique-id>
            <destination class="configured-consume-destination">
              <configured-thread-name>sfdc.create.contact</configured-thread-name>
              <destination>sfdc.create.contact</destination>
            </destination>
            <message-translator class="auto-convert-message-translator"/>
            <durable>false</durable>
          </consumer>
          <service-collection class="service-list">
            <services>
              <regexp-metadata-service>
                <unique-id>Capture Original Payload</unique-id>
                <regexp-metadata-query>
                  <metadata-key>tmp_original_xml</metadata-key>
                  <query-expression>(?s)(.*)</query-expression>
                </regexp-metadata-query>
              </regexp-metadata-service>
              <xpath-metadata-service>
                <xpath-query class="configured-xpath-query">
                  <metadata-key>LocalContactId</metadata-key>
                  <xpath-query>//Row/Id</xpath-query>
                </xpath-query>
                <xpath-query class="configured-xpath-query">
                  <metadata-key>LastUpdated</metadata-key>
                  <xpath-query>//Row/LastUpdated</xpath-query>
                </xpath-query>
              </xpath-metadata-service>
              <add-metadata-service>
                <unique-id>Add Static Metadata</unique-id>
                <metadata-element>
                  <key>baseUrl</key>
                  <value>${sfdc_request_base_url}</value>
                </metadata-element>
              </add-metadata-service>
              <xml-transform-service>
                <unique-id>Remove Extra Elements</unique-id>
                <url>${mappings_url}</url>
                <transform-parameter class="xml-transform-string-parameter">
                  <metadata-filter>
                    <include-pattern>.*</include-pattern>
                  </metadata-filter>
                </transform-parameter>
                <output-message-encoding>UTF-8</output-message-encoding>
                <xml-transformer-factory class="xslt-transformer-factory"/>
              </xml-transform-service>
              <json-xml-transform-service>
                <unique-id>Transform To SFDC JSON</unique-id>
                <direction>XML_TO_JSON</direction>
                <driver class="default-transformation-driver"/>
              </json-xml-transform-service>
              <clone-message-service-list>
                <unique-id>Get OAUTH Token</unique-id>
                <override-metadata>true</override-metadata>
                <override-metadata-filter class="regex-metadata-filter">
                  <include-pattern>^Authorization.*</include-pattern>
                </override-metadata-filter>
                <services>
                  <standalone-requestor>
                    <connection class="shared-connection">
                      <lookup-name>LocalActiveMQ</lookup-name>
                    </connection>
                    <producer class="jms-topic-producer">
                      <destination class="configured-produce-destination">
                        <destination>sfdc.authenticate</destination>
                      </destination>
                      <ignore-reply-metadata>false</ignore-reply-metadata>
                      <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
                      <message-translator class="text-message-translator">
                        <metadata-filter class="regex-metadata-filter">
                          <include-pattern>^Authorization.*</include-pattern>
                        </metadata-filter>
                      </message-translator>
                    </producer>
                    <reply-timeout>
                      <unit>SECONDS</unit>
                      <interval>30</interval>
                    </reply-timeout>
                  </standalone-requestor>
                </services>
              </clone-message-service-list>
              <standalone-requestor>
                <unique-id>Create Contact In SFDC</unique-id>
                <continue-on-fail>true</continue-on-fail>
                <producer class="standard-http-producer">
                  <destination class="metadata-destination">
                    <key>baseUrl</key>
                  </destination>
                  <content-type-provider class="http-configured-content-type-provider">
                    <mime-type>application/json</mime-type>
                  </content-type-provider>
                  <method-provider class="http-configured-request-method">
                    <method>POST</method>
                  </method-provider>
                  <response-header-handler class="http-response-headers-as-metadata"/>
                  <request-header-provider class="http-metadata-request-headers">
                    <filter class="regex-metadata-filter">
                      <include-pattern>^Authorization.*</include-pattern>
                    </filter>
                  </request-header-provider>
                </producer>
                <reply-timeout>
                  <unit>SECONDS</unit>
                  <interval>60</interval>
                </reply-timeout>
              </standalone-requestor>
              <branching-service-collection>
                <unique-id>CheckSuccessfulResponse</unique-id>
                <first-service-id>CheckResponseCode</first-service-id>
                <services>
                  <metadata-value-branching-service>
                    <unique-id>CheckResponseCode</unique-id>
                    <metadata-key>adphttpresponse</metadata-key>
                    <default-service-id>RetryUsingNewAccessToken</default-service-id>
                    <value-matcher class="integer-value-matcher"/>
                    <metadata-to-service-id-mappings>
                      <key-value-pair>
                        <key>=201</key>
                        <value>SuccessfulResponse</value>
                      </key-value-pair>
                    </metadata-to-service-id-mappings>
                  </metadata-value-branching-service>
                  <service-list>
                    <unique-id>SuccessfulResponse</unique-id>
                    <services>
                      <json-path-service>
                        <source class="string-payload-data-input-parameter"/>
                        <json-path-execution>
                          <source class="constant-data-input-parameter">
                            <value>$.id</value>
                          </source>
                          <target class="metadata-data-output-parameter">
                            <metadata-key>ContactId</metadata-key>
                          </target>
                        </json-path-execution>
                      </json-path-service>
                      <jdbc-raw-data-capture-service>
                        <unique-id>Store SFDC Contact Id</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalMySQL</lookup-name>
                        </connection>
                        <statement-timeout>
                          <unit>SECONDS</unit>
                          <interval>30</interval>
                        </statement-timeout>
                        <statement>update contacts set ContactId=? , LastUpdated=? where id=?</statement>
                        <parameter-applicator class="sequential-parameter-applicator"/>
                        <jdbc-statement-parameter>
                          <query-string>ContactId</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>LastUpdated</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                        <jdbc-statement-parameter>
                          <query-string>LocalContactId</query-string>
                          <query-class>java.lang.String</query-class>
                          <query-type>metadata</query-type>
                        </jdbc-statement-parameter>
                      </jdbc-raw-data-capture-service>
                    </services>
                  </service-list>
                  <service-list>
                    <unique-id>RevokeAccessTokenAndRetry</unique-id>
                    <services>
                      <standalone-requestor>
                        <unique-id>RemoveAuthorizationHeaderFromCache</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalActiveMQ</lookup-name>
                        </connection>
                        <producer class="jms-topic-producer">
                          <destination class="configured-produce-destination">
                            <destination>sfdc.authenticate.delete</destination>
                          </destination>
                          <message-translator class="text-message-translator"/>
                        </producer>
                        <reply-timeout>
                          <unit>SECONDS</unit>
                          <interval>30</interval>
                        </reply-timeout>
                      </standalone-requestor>
                      <payload-from-metadata-service>
                        <unique-id>Restore Original XML</unique-id>
                        <metadata-tokens>
                          <key-value-pair>
                            <key>tmp_original_xml</key>
                            <value>__PAYLOAD__</value>
                          </key-value-pair>
                        </metadata-tokens>
                        <template>__PAYLOAD__</template>
                      </payload-from-metadata-service>
                      <standalone-producer>
                        <unique-id>Recursion?</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalActiveMQ</lookup-name>
                        </connection>
                        <producer class="jms-topic-producer">
                          <destination class="configured-produce-destination">
                            <destination>sfdc.create.contact</destination>
                          </destination>
                          <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
                          <message-translator class="text-message-translator">
                            <metadata-filter class="remove-all-metadata-filter"/>
                          </message-translator>
                        </producer>
                      </standalone-producer>
                    </services>
                  </service-list>
                </services>
              </branching-service-collection>
            </services>
          </service-collection>
          <produce-exception-handler class="null-produce-exception-handler"/>
        </standard-workflow>
        <standard-workflow>
          <unique-id>Update Contacts</unique-id>
          <consumer class="jms-topic-consumer">
            <unique-id>sfdc.update.contact</unique-id>
            <destination class="configured-consume-destination">
              <configured-thread-name>sfdc.update.contact</configured-thread-name>
              <destination>sfdc.update.contact</destination>
            </destination>
            <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
            <message-translator class="auto-convert-message-translator"/>
            <correlation-id-source class="null-correlation-id-source"/>
            <durable>false</durable>
          </consumer>
          <service-collection class="service-list">
            <services>
              <regexp-metadata-service>
                <unique-id>Capture Original Payload</unique-id>
                <regexp-metadata-query>
                  <metadata-key>tmp_original_xml</metadata-key>
                  <query-expression>(?s)(.*)</query-expression>
                </regexp-metadata-query>
              </regexp-metadata-service>
              <xpath-metadata-service>
                <xpath-query class="configured-xpath-query">
                  <metadata-key>SfdcContactId</metadata-key>
                  <xpath-query>//Row/ContactId</xpath-query>
                </xpath-query>
              </xpath-metadata-service>
              <add-formatted-metadata-service>
                <unique-id>Generate Patch URL</unique-id>
                <format-string>${sfdc_request_base_url}%s?_HttpMethod=PATCH</format-string>
                <argument-metadata-key>SfdcContactId</argument-metadata-key>
                <metadata-key>SalesforcePatchUrl</metadata-key>
              </add-formatted-metadata-service>
              <xml-transform-service>
                <unique-id>Remove Extra Elements</unique-id>
                <url>${mappings_url}</url>
                <transform-parameter class="xml-transform-string-parameter">
                  <metadata-filter>
                    <include-pattern>.*</include-pattern>
                  </metadata-filter>
                </transform-parameter>
                <output-message-encoding>UTF-8</output-message-encoding>
                <xml-transformer-factory class="xslt-transformer-factory"/>
              </xml-transform-service>
              <json-xml-transform-service>
                <unique-id>Transform To SFDC JSON</unique-id>
                <direction>XML_TO_JSON</direction>
                <driver class="default-transformation-driver"/>
              </json-xml-transform-service>
              <clone-message-service-list>
                <unique-id>Get OAUTH Token</unique-id>
                <override-metadata>true</override-metadata>
                <override-metadata-filter class="regex-metadata-filter">
                  <include-pattern>^Authorization.*</include-pattern>
                </override-metadata-filter>
                <services>
                  <standalone-requestor>
                    <connection class="shared-connection">
                      <lookup-name>LocalActiveMQ</lookup-name>
                    </connection>
                    <producer class="jms-topic-producer">
                      <destination class="configured-produce-destination">
                        <destination>sfdc.authenticate</destination>
                      </destination>
                      <ignore-reply-metadata>false</ignore-reply-metadata>
                      <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
                      <message-translator class="text-message-translator">
                        <metadata-filter class="regex-metadata-filter">
                          <include-pattern>^Authorization.*</include-pattern>
                        </metadata-filter>
                      </message-translator>
                    </producer>
                    <reply-timeout>
                      <unit>SECONDS</unit>
                      <interval>30</interval>
                    </reply-timeout>
                  </standalone-requestor>
                </services>
              </clone-message-service-list>
              <standalone-requestor>
                <unique-id>Patch Contact In SFDC</unique-id>
                <continue-on-fail>true</continue-on-fail>
                <producer class="standard-http-producer">
                  <destination class="metadata-destination">
                    <key>SalesforcePatchUrl</key>
                  </destination>
                  <content-type-provider class="http-configured-content-type-provider">
                    <mime-type>application/json</mime-type>
                  </content-type-provider>
                  <method-provider class="http-configured-request-method">
                    <method>POST</method>
                  </method-provider>
                  <response-header-handler class="http-response-headers-as-metadata"/>
                  <request-header-provider class="http-metadata-request-headers">
                    <filter class="regex-metadata-filter">
                      <include-pattern>^Authorization.*</include-pattern>
                    </filter>
                  </request-header-provider>
                </producer>
                <reply-timeout>
                  <unit>SECONDS</unit>
                  <interval>60</interval>
                </reply-timeout>
              </standalone-requestor>
              <branching-service-collection>
                <unique-id>CheckSuccessfulResponse</unique-id>
                <first-service-id>CheckResponseCode</first-service-id>
                <services>
                  <metadata-value-branching-service>
                    <unique-id>CheckResponseCode</unique-id>
                    <metadata-key>adphttpresponse</metadata-key>
                    <default-service-id>RetryUsingNewAccessToken</default-service-id>
                    <value-matcher class="integer-value-matcher"/>
                    <metadata-to-service-id-mappings>
                      <key-value-pair>
                        <key>=204</key>
                        <value>SuccessfulResponse</value>
                      </key-value-pair>
                    </metadata-to-service-id-mappings>
                  </metadata-value-branching-service>
                  <service-list>
                    <unique-id>SuccessfulResponse</unique-id>
                    <services/>
                  </service-list>
                  <service-list>
                    <unique-id>RevokeAccessTokenAndRetry</unique-id>
                    <services>
                      <standalone-requestor>
                        <unique-id>RemoveAuthorizationHeaderFromCache</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalActiveMQ</lookup-name>
                        </connection>
                        <producer class="jms-topic-producer">
                          <destination class="configured-produce-destination">
                            <destination>sfdc.authenticate.delete</destination>
                          </destination>
                          <message-translator class="text-message-translator"/>
                        </producer>
                        <reply-timeout>
                          <unit>SECONDS</unit>
                          <interval>30</interval>
                        </reply-timeout>
                      </standalone-requestor>
                      <payload-from-metadata-service>
                        <unique-id>Restore Original XML</unique-id>
                        <metadata-tokens>
                          <key-value-pair>
                            <key>tmp_original_xml</key>
                            <value>__PAYLOAD__</value>
                          </key-value-pair>
                        </metadata-tokens>
                        <template>__PAYLOAD__</template>
                      </payload-from-metadata-service>
                      <standalone-producer>
                        <unique-id>Recursion?</unique-id>
                        <connection class="shared-connection">
                          <lookup-name>LocalActiveMQ</lookup-name>
                        </connection>
                        <producer class="jms-topic-producer">
                          <destination class="configured-produce-destination">
                            <destination>sfdc.update.contact</destination>
                          </destination>
                          <acknowledge-mode>CLIENT_ACKNOWLEDGE</acknowledge-mode>
                          <message-translator class="text-message-translator">
                            <metadata-filter class="remove-all-metadata-filter"/>
                          </message-translator>
                        </producer>
                      </standalone-producer>
                    </services>
                  </service-list>
                </services>
              </branching-service-collection>
            </services>
          </service-collection>
        </standard-workflow>
      </workflow-list>
    </channel>
  </channel-list>
  <message-error-digester class="standard-message-error-digester">
    <digest-max-size>100</digest-max-size>
    <unique-id>ErrorDigest</unique-id>
  </message-error-digester>
</adapter>